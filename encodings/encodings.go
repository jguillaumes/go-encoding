// Package encodings defines an implements an interface with methods to handle conversion from and to one-byte character encodings.
//
// The intended purpose is to convert between several IBM Mainframe EBCDIC encodings to and from golang strings and runes.
// It is based on character tables created by the CodecMapper utility, which can be found at:
//
// [https://github.com/roskakori/CodecMapper]
//
// Once the tables have been created, there is no runtime dependency to CodecMapper.
package encodings

import (
	"bufio"
	"bytes"
	"embed"
	"fmt"
	"path"
	"regexp"
	"strconv"
	"strings"

	log "github.com/sirupsen/logrus"
)

// Access to embedded tables created by CodecMapper. The tables must reside in the tables subdirectory under the package.
//
//go:embed tables
var encoding_tables embed.FS

// Regex to parse the encoding tables generated by CodecMapper.
//
// This is an example of one line of one of those tables:
//
//	0x0c	0x000c	#FORM FEED (FF)
//
// The first hexadecimal number is a byte representing a character in the target encoding.
// The second one is a 16 bit integer representing a rune.
const table_regex = "0x([0-9a-f]{2})\\s+0x([0-9a-f]{4})\\s+.*"

// An EncodingMap relates a rune to its byte representation in thr target encoding.
type EncodingMap map[rune]byte

// A DecodingTable contains the rune representation for each byte in the source encoding.
type DecodingTable []rune

// The EncodingData struct puts together an EncodingMap and a DecodingTable for a specific encoding.
type EncodingData struct {
	name          string
	encodingMap   *EncodingMap
	decodingTable *DecodingTable
}

// Encoding is the "main" interface exposed by this package, and contains methods to do the codepage conversions.
//
// A program using this package should obtain first an instance of Encoding:
//
//	myEnc := encodings.NewEncoding()
//
// Once this instance has been created, the user can invoke the provided methods to perform the actual conversions.
// The handling of the encoding tables is inrernal, although "manual" methods have been provided in case the
// user wants to do her or his own encoding or decoding procedures.
type Encoding interface {

	// GetEncodingMapFor obtains an [EncodingMap] for a given encoding name.
	GetEncodingMapFor(string) (*EncodingMap, error)

	// GetDecodingTableFor returns a [DecodingTable] corresponding to a given encoding name.
	// It will try to find an [EncodingData] corresponding to the encoding name. If it is not
	// found, it will try to create it using a decoding table present in the 'tables' subdirectory,
	// with a file name corresponding to the encoding name with the ".txt" extension.
	GetDecodingTableFor(string) (*DecodingTable, error)

	// EncodeString encodes a given golang string into a byte slice using a given encoding name.
	EncodeString(string, string) ([]byte, error)

	// DecodeBytes decodes a given byte slice into a golang string using a given encoding name.
	DecodeBytes([]byte, string) (string, error)

	// EncodeRune encodes a rune into a byte, using a given encoding name.
	EncodeRune(rune, string) (byte, error)

	// ListEncodings lists the available encodings as a string slice.
	ListEncodings() []string

	// This non-exported method builds the [EncodingMap] and [DecodingTable] corresponding
	// to an encofing table present in the tables subdirectory.
	generateEncoding(string) (*EncodingData, error)
}

// The encodingImpl (unexported) struct implements the [Encoding] interface.
type encodingImpl struct {
	Encoding
	encodings map[string]EncodingData
}

func (e *encodingImpl) GetDecodingTableFor(name string) (*DecodingTable, error) {
	var err error = nil
	ed, ok := e.encodings[name]
	if !ok {
		var edPtr *EncodingData
		edPtr, err = e.generateEncoding(name)
		if err == nil && edPtr != nil {
			ed = *edPtr
		}

	}
	if err != nil {
		return nil, err
	}
	return ed.decodingTable, nil
}

func (e *encodingImpl) GetEncodingMapFor(name string) (*EncodingMap, error) {
	var err error = nil
	ed, ok := e.encodings[name]
	if !ok {
		var edPtr *EncodingData
		edPtr, err = e.generateEncoding(name)
		if err == nil && edPtr != nil {
			ed = *edPtr
		}

	}
	if err != nil {
		return nil, err
	}
	return ed.encodingMap, nil
}

func (e *encodingImpl) DecodeBytes(bs []byte, code string) (string, error) {
	decoder, err := e.GetDecodingTableFor(code)
	if err != nil {
		return "", err
	}
	var builder strings.Builder
	for _, b := range bs {
		r := (*decoder)[b]
		builder.WriteRune(r)
	}
	return builder.String(), nil
}

func (e *encodingImpl) EncodeString(s string, code string) ([]byte, error) {
	tmpBuf := bytes.NewBuffer(make([]byte, 0, len(s)*2))
	encoder, err := e.GetEncodingMapFor(code)
	if err != nil {
		return nil, err
	}
	// Loop over the runes in s
	var r rune
	const blank rune = ' '
	for _, r = range s {
		b, ok := (*encoder)[r]
		if !ok {
			log.Warnf("No encoding for the rune %v in %s, set to an encoded space\n", r, code)

			b = (*encoder)[blank]
		}
		tmpBuf.WriteByte(b)
	}
	return tmpBuf.Bytes()[0:tmpBuf.Len()], nil
}

func (e *encodingImpl) EncodeRune(r rune, code string) (byte, error) {
	encoder, err := e.GetEncodingMapFor(code)
	if err != nil {
		return 0, err
	}
	b, ok := (*encoder)[r]
	if ok {
		return b, nil
	} else {
		return 0, fmt.Errorf("there is no encoding for the rune %v in the %s codemap", r, code)
	}
}

func (e *encodingImpl) generateEncoding(name string) (*EncodingData, error) {
	re, _ := regexp.Compile(table_regex)
	fileName := path.Join("tables", name+".txt")
	log.Debugf("Building the encoding table %s from %s\n", name, fileName)
	encodingMap := make(EncodingMap)
	decodingTable := make(DecodingTable, 256)
	tableData, err := encoding_tables.ReadFile(fileName)
	if err != nil {
		return nil, err
	}

	scanner := bufio.NewScanner(bytes.NewReader(tableData))
	for scanner.Scan() {
		line := scanner.Text()
		if line[0] != '#' {
			parts := re.FindStringSubmatch(line)
			if len(parts) != 3 {
				log.Printf("Malformed/unparsable line: [%s]", line)
			} else {
				i, _ := strconv.ParseUint(parts[1], 16, 8)
				v, _ := strconv.ParseUint(parts[2], 16, 16)
				decodingTable[i] = rune(v)
				encodingMap[rune(v)] = byte(i)
			}
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	encodingData := &EncodingData{
		name:          name,
		encodingMap:   &encodingMap,
		decodingTable: &decodingTable,
	}
	e.encodings[name] = *encodingData
	return encodingData, nil
}

func (e *encodingImpl) ListEncodings() []string {
	files, _ := encoding_tables.ReadDir("tables")
	list := make([]string, 0, len(files))
	for _, f := range files {
		n := f.Name()
		if strings.HasSuffix(n, ".txt") {
			list = append(list, strings.TrimSuffix(n, ".txt"))
		}
	}
	return list
}

// The NewEncoding function returns an [Encoding] instance ready to be used.
func NewEncoding() Encoding {
	impl := &encodingImpl{
		encodings: make(map[string]EncodingData),
	}
	return impl
}
